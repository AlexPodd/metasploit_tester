package ciinterface

import (
	"fmt"
	"io"

	"github.com/AlexPodd/metasploit_tester_console/internal/domain"
	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

var (
	appStyle = lipgloss.NewStyle().Padding(1, 2)
)

type ChoseExploit struct {
	list     list.Model
	selected map[string]bool
	exploits []domain.Exploit
	app      *App
}

func (m *ChoseExploit) Init() tea.Cmd {
	return nil
}

func (m *ChoseExploit) ChosenExploits() []string {
	var exploitPath []string
	for _, e := range m.exploits {
		if m.selected[e.Path] {
			exploitPath = append(exploitPath, e.Path)
		}
	}
	return exploitPath
}
func (m *ChoseExploit) Update(msg tea.Msg) (tea.Model, tea.Cmd) {

	switch msg := msg.(type) {
	case tea.KeyMsg:
		if m.list.FilterState() == list.Filtering {
			break
		}

		switch msg.String() {
		case "a":
			for _, item := range m.list.VisibleItems() {
				if exploit, ok := item.(domain.Exploit); ok {
					m.selected[exploit.Path] = true
				}
			}
			return m, nil

		case "A":
			for _, item := range m.list.VisibleItems() {
				if exploit, ok := item.(domain.Exploit); ok {
					m.selected[exploit.Path] = false
				}
			}
			return m, nil

		case "esc":
			return m.app.homePage, nil

		case " ":
			idx := m.list.Index()
			if idx >= 0 && idx < len(m.list.VisibleItems()) {
				if exploit, ok := m.list.VisibleItems()[idx].(domain.Exploit); ok {
					if m.selected[exploit.Path] {
						delete(m.selected, exploit.Path)
					} else {
						m.selected[exploit.Path] = true
					}
				}
			}
			return m, nil

		case "i":
			idx := m.list.Index()
			if idx >= 0 && idx < len(m.list.VisibleItems()) {
				if exploit, ok := m.list.VisibleItems()[idx].(domain.Exploit); ok {
					return NewExploitInfoModel(exploit, m.app), nil
				}
			}
		}
	}

	var cmd tea.Cmd
	m.list, cmd = m.list.Update(msg)
	return m, cmd
}
func (m *ChoseExploit) View() string {
	return appStyle.Render(m.list.View())
}

func NewChoseExploit(exploitsInfo []domain.Exploit, exploits []list.Item, app *App) *ChoseExploit {
	selected := make(map[string]bool)
	delegate := NewExploitDelegate(selected)
	l := list.New(exploits, delegate, 40, 20)
	l.Title = "Exploits"
	l.SetFilteringEnabled(true)
	return &ChoseExploit{
		list:     l,
		selected: selected,
		app:      app,
		exploits: exploitsInfo,
	}
}

type ExploitDelegate struct {
	selected map[string]bool
	list.DefaultDelegate
}

func NewExploitDelegate(selected map[string]bool) *ExploitDelegate {
	return &ExploitDelegate{
		selected: selected,
	}
}

func (d *ExploitDelegate) Render(w io.Writer, m list.Model, index int, item list.Item) {
	exploit := item.(domain.Exploit)

	checked := "[ ]"
	if d.selected[exploit.Path] {
		checked = "[x]"
	}

	cursor := " "
	if index == m.Index() {
		cursor = ">"
	}

	// Можно добавить цвета, стили и т.д.
	line := fmt.Sprintf("%s %s %s\n", cursor, checked, exploit.Name)
	fmt.Fprint(w, line)
}
